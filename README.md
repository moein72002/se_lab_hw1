## خلاصه کار
در این آزمایش هدف ما پیاده سازی یک سایت ساده برای تمرین و بررسی ویژگی های مختلف git بود.
خلاصه کارهایی که انجام دادیم به صورت زیر است:
1) راه اندازی مخزن گیتهاب و نوشتن پاسخ پرسش ها
2) اضافه کردن اسکلت پایه در index.html به همراه کمی css
3) اضافه کردن فیچرهای مختلف (مثل عکس گربه و جدول گربه ها)‌و استایل دادن به آن ها
4) ایجاد دو کانفلیکت عمدی جهت رفع آن ها (یک کانفلیکت روی برنچ feature از طریق تغییر همزمان فایل ها و یک کانفلیکت از طریق pull request روی main)
5) اضافه کردن بخش های progress bar و accordion به index.html
6) اضافه کردن استایل های نهایی
7) اضافه کردن یک workflow (سایت نهایی از طریق لینک https://moein72002.github.io/se_lab_hw1/ قابل دسترسی است.)

## پرسش ها
1) پوشه‌ی.git  یک دایرکتوری مخفی است که در هر مخزن (repository) گیت ایجاد می‌شود و شامل تمام اطلاعات مربوط به پروژه و تاریخچه‌ی تغییرات آن است. اطلاعاتی که در این پوشه ذخیره می‌شود شامل موارد زیر است:
    1.	تاریخچه‌ی کامیت‌ها تمامی تغییرات و نسخه‌های مختلف فایل‌ها ذخیره می‌شود.
    2.	برنچ‌ها و تگ‌ها اطلاعات مربوط به برنچ‌ها (branches) و تگ‌ها (tags) پروژه.
    3.	متادیتا اطلاعات مربوط به تنظیمات مخزن، شامل پیکربندی‌ها و اطلاعات مربوط به ریموت‌ها (remotes).
    4.	ایندکس(Index) فایل‌هایی که برای کامیت بعدی آماده شده‌اند.
    5.	اشیاء (Objects)محتوای فایل‌ها و تغییرات آنها که به صورت باینری ذخیره می‌شود.
    برای ایجاد یک پوشه‌ی .git، کافیست به دایرکتوری پروژه بروید و دستور زیر را اجرا کنید:
    git init
    این دستور یک مخزن جدید گیت ایجاد می‌کند و پوشه‌ی .git را در دایرکتوری فعلی ایجاد می‌نماید.

2)
در زمینه‌ی atomic commit و atomic pull request، مفهوم atomic به معنای «اتمیک» یا «غیرقابل تقسیم» است. این مفهوم در گیت و فرآیندهای توسعه نرم‌افزار به دو صورت زیر توضیح داده می‌شود:
Atomic Commit
•	تعریف: یک atomic commit به این معناست که تغییرات یک کامیت به طور کامل و در یک واحد انجام می‌شود. این بدین معناست که هر کامیت باید یک تغییر منطقی و معنادار را نمایندگی کند و نباید کامیت‌ها به صورت جزئی یا ناقص باشند.
•	مزایا:
o	ساده‌تر برای بررسی تاریخچه تغییرات، زیرا هر کامیت نمایانگر یک تغییر کامل است.
o	امکان بازگشت به حالت قبلی بدون نگرانی از از دست رفتن بخشی از تغییرات.
o	تسهیل در همکاری تیمی، زیرا هر عضو تیم می‌تواند با تغییرات واضح و مشخص کار کند.
Atomic Pull Request
•	تعریف: یک atomic pull request به معنای درخواست ادغام (merge) است که تغییرات آن به صورت یک واحد منسجم و منطقی ارائه می‌شود. این بدان معناست که تمامی تغییرات پیشنهادی در یک pull request باید مربوط به یک ویژگی یا اصلاح خاص باشند و نباید شامل تغییرات غیر مرتبط باشند.
•	مزایا:
o	تسهیل در بازبینی (review) تغییرات، زیرا بازبین‌ها می‌توانند تغییرات را در یک زمینه خاص بررسی کنند.
o	کاهش احتمال بروز مشکلات در ادغام، زیرا همه‌ی تغییرات به صورت همزمان و مرتبط با هم ارائه می‌شوند.
o	مدیریت آسان‌تر پروژه و کد منبع، زیرا هر pull request نمایانگر یک ویژگی یا اصلاح خاص است.
در مجموع، atomic بودن در این زمینه‌ها به مدیریت بهتر و واضح‌تر تغییرات کد کمک می‌کند و فرآیندهای همکاری را تسهیل می‌نماید.


3) 
    1. git fetch
    •	عملکرد: این دستور به شما اجازه می‌دهد تا تغییرات جدید از مخزن ریموت را به مخزن محلی خود دانلود کنید، بدون اینکه این تغییرات را به برنچ فعلی شما ادغام کند.
    •	استفاده: به‌خصوص زمانی که می‌خواهید ببینید چه تغییراتی در مخزن ریموت وجود دارد، بدون اینکه تغییرات جدید را بلافاصله در کد خود اعمال کنید.
    •	نتیجه: اطلاعات جدید در مورد برنچ‌های ریموت به محلی شما دانلود می‌شود، اما هیچ کدی تغییر نمی‌کند.
    2. git pull
    •	عملکرد: این دستور ترکیبی از fetch و merge است. ابتدا تغییرات جدید را از مخزن ریموت دانلود می‌کند (مانند fetch) و سپس آن تغییرات را به برنچ فعلی شما ادغام می‌کند.
    •	استفاده: زمانی که می‌خواهید آخرین تغییرات ریموت را به طور مستقیم به کد محلی خود اضافه کنید.
    •	نتیجه: برنچ فعلی شما به‌روز می‌شود و تغییرات جدید به آن ادغام می‌شود.
    3. git merge
    •	عملکرد: این دستور برای ادغام دو برنچ مختلف استفاده می‌شود. تغییرات یک برنچ (مانند برنچ ریموت) به برنچ فعلی ادغام می‌شود.
    •	استفاده: زمانی که می‌خواهید تغییرات یک برنچ را به برنچ دیگر (مانند ادغام یک ویژگی جدید به برنچ اصلی) اضافه کنید.
    •	نتیجه: یک کامیت جدید ایجاد می‌شود که نمایانگر ادغام دو برنچ است. این کامیت می‌تواند شامل ترکیبی از تغییرات دو برنچ باشد.
    4. git rebase
    •	عملکرد: این دستور برای ادغام تغییرات از یک برنچ به برنچ دیگر با تغییر تاریخچه استفاده می‌شود. در واقع، rebase تغییرات یک برنچ را بر اساس برنچ دیگری قرار می‌دهد.
    •	استفاده: برای حفظ تاریخچه‌ای تمیز و خطی از تغییرات، به‌خصوص در پروژه‌هایی که همکاری زیادی دارند.
    •	نتیجه: تاریخچه‌ی کامیت‌ها تغییر می‌کند و به‌جای ایجاد یک کامیت جدید برای ادغام، کامیت‌های جدید به‌طور مستقیم بر اساس برنچ مورد نظر قرار می‌گیرند.
    5. git cherry-pick
    •	عملکرد: این دستور به شما اجازه می‌دهد تا یک یا چند کامیت خاص را از یک برنچ به برنچ دیگر منتقل کنید.
    •	استفاده: زمانی که می‌خواهید یک تغییر خاص (کامیت) را بدون ادغام کامل برنچ، به برنچ فعلی اضافه کنید.
    •	نتیجه: کامیت‌های انتخابی به برنچ فعلی شما افزوده می‌شوند و این کامیت‌ها به عنوان کامیت‌های جدید در برنچ فعلی نمایش داده می‌شوند.
    خلاصه:
    •	fetch: دانلود تغییرات بدون ادغام.
    •	pull: دانلود و ادغام تغییرات.
    •	merge: ادغام دو برنچ با ایجاد یک کامیت جدید.
    •	rebase: ادغام با تغییر تاریخچه برای یک نمای خطی.
    •	cherry-pick: انتقال کامیت‌های خاص به برنچ دیگر.

4)
1. git reset
ش	عملکرد: این دستور برای بازگرداندن HEAD به یک کامیت خاص و تغییر تاریخچه‌ی کامیت‌ها استفاده می‌شود.
•	استفاده: زمانی که می‌خواهید کامیت‌های اخیر را حذف کنید یا تغییرات را به وضعیت قبلی برگردانید.
•	نتیجه: تغییرات بسته به گزینه‌ای که استفاده می‌کنید می‌تواند در ایندکس و دایرکتوری کاری شما تأثیر بگذارد. برای 2. git revert
•	عملکرد: این دستور برای ایجاد یک کامیت جدید است که تغییرات یک کامیت قبلی را معکوس می‌کند.
ن	استفاده: زمانی که می‌خواهید یک تغییر خاص را برگردانید، اما می‌خواهید تاریخچه‌ی کامیت‌ها را حفظ کنید.
•	نتیجه: یک کامیت جدید ایجاد می‌شود که دقیقاً معکوس تغییرات کامیت مشخص شده است.
3. git restore
ش	عملکرد: این دستور برای بازگرداندن فایل‌ها به وضعیت خاصی در ایندکس یا دایرکتوری کاری استفاده می‌شود.
•	استفاده: زمانی که می‌خواهید فایل‌های خاصی را به وضعیت یک کامیت مشخص برگردانید یا تغییرات محلی را نادیده بگیرید.
•	نتیجه: با استفاده از گزینه‌های مختلف، می‌توانید فایل‌ها را از ایندکس یا تاریخچه‌ی کامیت‌ها بازیابی کنید.
4. git switch
•	عملکرد: این دستور برای تغییر برنچ‌ها استفاده می‌شود و یکی از دستورات جدید گیت است که جایگزین checkout برای تغییر برنچ می‌شود.
‌	استفاده: برای سوئیچ کردن به برنچ‌های دیگر به‌صورت ساده‌تر.
ک	نتیجه: به‌طور مستقیم به برنچ مشخص شده تغییر می‌کند.
5. git checkout
ش	عملکرد: این دستور برای تغییر برنچ‌ها یا بازگرداندن فایل‌ها به وضعیت خاصی استفاده می‌شود.
•	استفاده: می‌توان از آن برای تغییر به برنچ‌های دیگر یا بازگرداندن فایل‌ها به وضعیت کامیت‌های قبلی استفاده کرد.
خلاصه:
•	reset: بازگرداندن HEAD و تغییر تاریخچه (تأثیر بر ایندکس و دایرکتوری کاری).
•	revert: ایجاد کامیت جدید که تغییرات یک کامیت قبلی را معکوس می‌کند.
•	restore: بازگرداندن فایل‌ها به وضعیت خاصی از ایندکس یا تاریخچه.
•	switch: تغییر برنچ‌ها به صورت ساده و جدید.
•	checkout: تغییر برنچ‌ها یا بازگرداندن فایل‌ها به وضعیت کامیت‌های قبلی (بیشتر کاربردهای متنوع).


5) 
    Stage (Index)
    •	Stage  یا Index در گیت به منطقه‌ای اشاره دارد که تغییرات فایل‌ها قبل از کامیت شدن به آن اضافه می‌شوند. این منطقه به شما اجازه می‌دهد که تغییرات را جمع‌آوری و مدیریت کنید قبل از اینکه آنها را به تاریخچه پروژه اضافه کنید.
    •	عملکرد:
    o	زمانی که تغییراتی در فایل‌های پروژه ایجاد می‌کنید، باید این تغییرات را به Stage اضافه کنید تا گیت آنها را برای کامیت بعدی شناسایی کند.
    o	با استفاده از دستور git add <file>، فایل‌های مورد نظر به Stage اضافه می‌شوند.
    •	مزایا:
    o	امکان انتخاب دقیق تغییراتی که می‌خواهید در کامیت بعدی شامل کنید.
    o	مدیریت بهتر و سازمان‌دهی تغییرات قبل از ثبت آنها در تاریخچه.
    git stash
    •	عملکرد: دستور stash به شما اجازه می‌دهد تا تغییرات محلی خود را موقتاً ذخیره کنید بدون اینکه آنها را کامیت کنید. این کار به‌خصوص زمانی مفید است که می‌خواهید به برنچ دیگری سوئیچ کنید اما نمی‌خواهید تغییرات جاری خود را از دست بدهید یا کامیت کنید.
    •	استفاده:
    o	برای ذخیره‌ی تغییرات جاری در دایرکتوری کاری و ایندکس، می‌توانید از دستور زیر استفاده کنید:
    bash
    Copy code
    git stash
    o	با این کار، تغییرات شما در یک مکان موقتی ذخیره می‌شود و دایرکتوری کاری به آخرین وضعیت کامیت برمی‌گردد.
    •	نتیجه:
    o	تغییرات ذخیره شده به صورت یک stash در تاریخچه‌ی stash قرار می‌گیرند و می‌توانید در آینده با استفاده از دستور git stash apply یا git stash pop آنها را بازیابی کنید.
    o	git stash apply تغییرات را به دایرکتوری کاری برمی‌گرداند اما stash را پاک نمی‌کند، در حالی که git stash pop تغییرات را برمی‌گرداند و stash را پاک می‌کند.
    خلاصه:
    •	Stage (Index): ناحیه‌ای برای جمع‌آوری و مدیریت تغییرات قبل از کامیت.
    •	git stash: ذخیره‌ی موقت تغییرات محلی بدون کامیت، به‌خصوص برای سوئیچ کردن برنچ‌ها.


6)
مفهوم Snapshot
•	تعریف: Snapshot به معنای یک تصویر (عکس) از وضعیت یک پروژه در یک نقطه‌ی خاص زمانی است. در زمینه‌ی گیت، هر کامیت یک snapshot از دایرکتوری کاری و تمام فایل‌های آن را شامل می‌شود. این snapshot شامل تمام تغییرات و محتوای فایل‌ها است و به شما این امکان را می‌دهد که به وضعیت پروژه در آن زمان خاص برگردید.
ارتباط Snapshot با Commit
•	هر Commit به عنوان Snapshot:
o	هر بار که شما یک کامیت در گیت ایجاد می‌کنید (با دستور git commit)، گیت یک snapshot از تمامی فایل‌های پروژه در آن لحظه می‌گیرد. این snapshot شامل محتویات فایل‌ها، زمان کامیت و اطلاعات دیگر مانند پیام کامیت است.
o	به طور کلی، هر کامیت می‌تواند به عنوان یک نقطه‌ی بازگشت در تاریخچه‌ی پروژه عمل کند. شما می‌توانید با استفاده از دستور git checkout به هر کامیت خاص برگردید و وضعیت پروژه را در آن زمان مشاهده کنید.
•	مدیریت تاریخچه:
o	با وجود snapshots مختلف، می‌توانید تاریخچه‌ی تغییرات پروژه را به راحتی پیگیری کنید و به وضعیت‌های قبلی برگردید. این امکان به شما اجازه می‌دهد تا تغییرات را در پروژه خود مدیریت کنید و در صورت نیاز، به تغییرات خاصی که ممکن است موجب بروز مشکلات شوند، مراجعه کنید.
مزایای استفاده از Snapshots
1.	بازگشت به وضعیت‌های قبلی: می‌توانید به راحتی به وضعیت‌های قبلی پروژه برگردید و از مشکلات اجتناب کنید.
2.	تاریخچه تغییرات: با وجود snapshots، می‌توانید تاریخچه‌ی دقیقی از تغییرات پروژه را داشته باشید و بررسی کنید که چه تغییراتی در هر کامیت ایجاد شده است.
3.	مدیریت نسخه: Snapshots به شما این امکان را می‌دهند که نسخه‌های مختلفی از پروژه را به راحتی مدیریت کنید و از آنها استفاده کنید.
خلاصه
•	Snapshot: یک تصویر از وضعیت پروژه در یک زمان خاص.
•	Commit: عمل ایجاد یک snapshot از دایرکتوری کاری و ذخیره‌ی آن در تاریخچه‌ی پروژه. هر کامیت نمایانگر یک وضعیت خاص از پروژه است که می‌توانید به آن بازگردید.


7) 
در گیت، local repository و remote repository دو نوع مخزن (repository) هستند که هرکدام ویژگی‌ها و کاربردهای خاص خود را دارند. در زیر به تفاوت‌های اصلی بین این دو نوع مخزن پرداخته شده است:
محل ذخیره‌سازی
•	Local Repository:
o	مخزن محلی است که بر روی سیستم شما (کامپیوتر) ذخیره شده است.
o	همه‌ی فایل‌ها، تاریخچه‌ی تغییرات و تنظیمات مرتبط با پروژه در این مخزن قرار دارد.
•	Remote Repository:
o	مخزن دور (ریموت) است که معمولاً بر روی یک سرور (مثل GitHub، GitLab یا Bitbucket) ذخیره می‌شود.
o	این مخزن به اعضای تیم و سایر افراد اجازه می‌دهد که به پروژه دسترسی داشته و با آن همکاری کنند.
دسترسی و همکاری
•	Local Repository:
o	فقط بر روی سیستم شما قابل دسترسی است و شما می‌توانید به راحتی و به‌صورت آفلاین تغییرات را انجام دهید.
o	برای اشتراک‌گذاری تغییرات با دیگران، باید آنها را به مخزن ریموت ارسال کنید.
•	Remote Repository:
o	به دیگر اعضای تیم و افراد خارج از تیم اجازه می‌دهد که به پروژه دسترسی داشته باشند و با آن همکاری کنند.
o	معمولاً از طریق پروتکل‌های شبکه (مثل HTTPS یا SSH) به آن دسترسی پیدا می‌شود.
عملکرد دستورات
•	Local Repository:
o	می‌توانید از دستورات گیت مانند git add، git commit و git checkout به راحتی در این مخزن استفاده کنید.
o	تغییرات محلی را به سرعت اعمال و مدیریت کنید.
•	Remote Repository:
o	از دستورات مانند git push و git pull برای ارسال یا دریافت تغییرات از مخزن ریموت استفاده می‌شود.
o	نیاز به اتصال به اینترنت برای تعامل با این مخزن دارید.
تاریخچه تغییرات
•	Local Repository:
o	شامل تاریخچه‌ی تغییرات خاص به سیستم شما است و می‌توانید تغییرات خود را به‌صورت محلی مدیریت کنید.
•	Remote Repository:
o	شامل تاریخچه‌ی تغییرات کلی پروژه است که توسط تمام اعضای تیم انجام شده است و می‌تواند شامل کامیت‌ها و تغییرات مختلف باشد.
نسخه‌برداری
•	Local Repository:
o	هر کاربر می‌تواند یک کپی از مخزن ریموت را بر روی سیستم خود دانلود کند و تغییرات را به‌صورت مستقل انجام دهد.
•	Remote Repository:
o	مخزن مرکزی است که معمولاً آخرین و کامل‌ترین نسخه‌ی پروژه را نگهداری می‌کند و می‌تواند شامل تغییرات سایر اعضای تیم باشد.
خلاصه
•	Local Repository: مخزن محلی بر روی سیستم کاربر، با دسترسی آسان و تغییرات مستقل.
•	Remote Repository: مخزن دور بر روی سرور، با دسترسی مشترک برای همکاری و نیاز به اینترنت برای تعامل.
